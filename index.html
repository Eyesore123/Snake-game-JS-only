<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake Game</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1 class="title" id="title">Snake Game</h1>
    <!-- Game over -->
    <div class="gameOver" id="gameOver" style="display: none;">
        GAME OVER
    </div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <p id="score" class="score" hidden>Score: 0</p>
    <button onclick=initStyles() id="startBtn">Start Game</button>
    <button id="restartBtn" onclick=restartGame() hidden>Restart Game</button>
    <footer>
        <div>
            <p id="footertext" style="display: none;">Tap on screen to pause</p>
        </div>
    </footer>

    <script>

        function initStyles() {
            document.getElementById('gameCanvas').style.opacity = 1;
            document.getElementById('score').style.display = 'block';
            document.getElementById('title').style.display = 'none';
            document.getElementById('footertext').style.display = 'flex';
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const startBtn = document.getElementById('startBtn');

        let gameStarted = false;
        let snake = [];
        let food = {};

        // Movement variables (speed on the x and y axis)
        // Only one can be active at a time, otherwise the snake would move diagonally
        let dx = 0;
        let dy = 0;

        let score = 0;
        let gridSize = 20;
        let over = false;
        let paused = false;

        // Movement happens in intervals. When the game ends, the interval is cleared.
        let moveInterval;

        function togglePause() {
            paused = !paused;
            if (paused) {
                clearInterval(moveInterval);
            } else {
                moveInterval = setInterval(moveSnake, 200);
            }
        }

        function handleClick() {
            console.log("clicked");
            togglePause();
        }

        // Event listeners

       document.getElementById('gameCanvas').addEventListener('click', handleClick);

        function restartGame() {
            snake = [];
            gameStarted = false;
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            document.getElementById('restartBtn').style.display = 'block';
            document.getElementById('gameOver').style.display = 'none';
            initGame();
        }

    

        function initGame() {

            // Dynamic buttons:
            document.getElementById('restartBtn').style.display = 'block';
            document.getElementById('startBtn').style.display = 'none';

            // Reset game state
            gameStarted = true;
            // Adjust the snake length at game start:
            snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            dx = 1;  // Initial movement speed
            dy = 0;

            placeFood();
            drawGame();

            // Move the snake every 200 milliseconds (5 moves per second)
            if (!moveInterval) {
            moveInterval = setInterval(moveSnake, 200);
            }
        }

        function drawGame() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Dynamic rendering of the snake where the color is determined by the index of the segment in the snake array
            for (let i = 0; i < snake.length; i++) {
                ctx.fillStyle = `hsl(${120 * i}, 70%, 60%)`;
                // Green color: ctx.fillStyle = `green`; 
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2);
            }

            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);

            // Grid line colors and thickness
            ctx.strokeStyle = '';
            for (let i = 0; i <= canvas.width / gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
        }

        function placeFood() {
            let validFood = false;
            while (!validFood) {
                food = {
                    x: Math.floor(Math.random() * (canvas.width / gridSize)),
                    y: Math.floor(Math.random() * (canvas.height / gridSize))
                };

                validFood = true;
                for (let segment of snake) {
                    if (segment.x === food.x && segment.y === food.y) {
                        validFood = false;
                        break;
                    }
                }
            }
        }

        function moveSnake() {
            if(!gameStarted || paused) return;

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Currently the game ends if the snake runs into itself or the wall.

            if (head.x < 0 || head.x >= canvas.width / gridSize ||
                head.y < 0 || head.y >= canvas.height / gridSize) {
                over = true;
                if(over === true) {
                    document.getElementById('gameOver').style.display = 'flex';
                }
                clearInterval(moveInterval);
            }

            // Add an option to run through the walls.
            
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    over = true;
                    if(over === true) {
                        document.getElementById('gameOver').style.display = 'flex';
                    }
                    clearInterval(moveInterval);
                    return;
                }
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreElement.textContent = `Score: ${score}`;
                placeFood();
            } else {
                snake.pop();
            }

            drawGame();
        }

        function handleKeyPress(e) {
            switch (e.key) {

                // Return statement prevents the opposite movements

                case 'ArrowUp':
                    if (dy === 1) return;
                    dx = 0; dy = -1;
                    break;
                case 'ArrowDown':
                    if (dy === -1) return;
                    dx = 0; dy = 1;
                    break;
                case 'ArrowLeft':
                    if (dx === 1) return;
                    dx = -1; dy = 0;
                    break;
                case 'ArrowRight':
                    if (dx === -1) return;
                    dx = 1; dy = 0;
                    break;
            }
        }

        document.addEventListener('keydown', handleKeyPress);
        startBtn.addEventListener('click', initGame);
        
    </script>
</body>
</html>

<!-- Only the latest keypress needs to register before the next drawgame cycle. Otherwise the keypresses can happen faster than the game can draw (game ends without snake moving). -->
 <!-- Stylings for btns, score, snake -->
  <!-- Pause button (p for keyboard, tap screen for mobile) -->
   <!-- Random spawns -->
    <!-- Enemies -->
     <!-- Game over screen and effects -->
      <!-- Different difficulty modes -->
       <!-- Buttons for mobile -->
